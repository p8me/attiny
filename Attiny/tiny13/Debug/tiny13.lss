
tiny13.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000236  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000236  000002ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000f  00800062  00800062  000002cc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000002cc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000002fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  00000338  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000007cd  00000000  00000000  00000438  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000004ce  00000000  00000000  00000c05  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000776  00000000  00000000  000010d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000019c  00000000  00000000  0000184c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000313  00000000  00000000  000019e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000288  00000000  00000000  00001cfb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00001f83  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	09 c0       	rjmp	.+18     	; 0x14 <__ctors_end>
   2:	21 c0       	rjmp	.+66     	; 0x46 <__bad_interrupt>
   4:	20 c0       	rjmp	.+64     	; 0x46 <__bad_interrupt>
   6:	1f c0       	rjmp	.+62     	; 0x46 <__bad_interrupt>
   8:	1e c0       	rjmp	.+60     	; 0x46 <__bad_interrupt>
   a:	1d c0       	rjmp	.+58     	; 0x46 <__bad_interrupt>
   c:	1c c0       	rjmp	.+56     	; 0x46 <__bad_interrupt>
   e:	1b c0       	rjmp	.+54     	; 0x46 <__bad_interrupt>
  10:	47 c0       	rjmp	.+142    	; 0xa0 <__vector_8>
  12:	19 c0       	rjmp	.+50     	; 0x46 <__bad_interrupt>

00000014 <__ctors_end>:
  14:	11 24       	eor	r1, r1
  16:	1f be       	out	0x3f, r1	; 63
  18:	cf e9       	ldi	r28, 0x9F	; 159
  1a:	cd bf       	out	0x3d, r28	; 61

0000001c <__do_copy_data>:
  1c:	10 e0       	ldi	r17, 0x00	; 0
  1e:	a0 e6       	ldi	r26, 0x60	; 96
  20:	b0 e0       	ldi	r27, 0x00	; 0
  22:	e6 e3       	ldi	r30, 0x36	; 54
  24:	f2 e0       	ldi	r31, 0x02	; 2
  26:	02 c0       	rjmp	.+4      	; 0x2c <__do_copy_data+0x10>
  28:	05 90       	lpm	r0, Z+
  2a:	0d 92       	st	X+, r0
  2c:	a2 36       	cpi	r26, 0x62	; 98
  2e:	b1 07       	cpc	r27, r17
  30:	d9 f7       	brne	.-10     	; 0x28 <__do_copy_data+0xc>

00000032 <__do_clear_bss>:
  32:	20 e0       	ldi	r18, 0x00	; 0
  34:	a2 e6       	ldi	r26, 0x62	; 98
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	01 c0       	rjmp	.+2      	; 0x3c <.do_clear_bss_start>

0000003a <.do_clear_bss_loop>:
  3a:	1d 92       	st	X+, r1

0000003c <.do_clear_bss_start>:
  3c:	a1 37       	cpi	r26, 0x71	; 113
  3e:	b2 07       	cpc	r27, r18
  40:	e1 f7       	brne	.-8      	; 0x3a <.do_clear_bss_loop>
  42:	07 d0       	rcall	.+14     	; 0x52 <main>
  44:	f6 c0       	rjmp	.+492    	; 0x232 <_exit>

00000046 <__bad_interrupt>:
  46:	dc cf       	rjmp	.-72     	; 0x0 <__vectors>

00000048 <adc_init>:
                              GND -|4--------5|- PB0 (MOSI/DI/SDA/AIN0/OC0A/OC1A/AREF/PCINT0)  */
const uint8_t adc_pin_2_ch[] = {-1, -1, 1, 3, 2, 0};
#define ADC_PIN_2_CH(x) adc_pin_2_ch[x]

void adc_init(void){
	ADMUX = _BV(ADLAR);// + _BV(ADC_INT_1V1); // MUX
  48:	80 e2       	ldi	r24, 0x20	; 32
  4a:	87 b9       	out	0x07, r24	; 7
	ADCSRA = 1; // 2^1 PRESC
  4c:	81 e0       	ldi	r24, 0x01	; 1
  4e:	86 b9       	out	0x06, r24	; 6
  50:	08 95       	ret

00000052 <main>:
	#if(!TINY13)
	dbg_tx_init();
	#endif

	// ============= Clock ================
	CLKPR = _BV(CLKPCE); CLKPR = CPU_PRESC;
  52:	80 e8       	ldi	r24, 0x80	; 128
  54:	86 bd       	out	0x26, r24	; 38
  56:	16 bc       	out	0x26, r1	; 38

	// ========== Enable Sleep ============
#if WDT
	set_bit(MCUCR, SM1); // incompatible with PWM
  58:	85 b7       	in	r24, 0x35	; 53
  5a:	80 61       	ori	r24, 0x10	; 16
  5c:	85 bf       	out	0x35, r24	; 53
#endif
	init();
  5e:	e6 d0       	rcall	.+460    	; 0x22c <init>

	while(1){
#if WDT
		sleep_cpu();
  60:	88 95       	sleep
		if (wdt_timeout_happened()) wdt_event();
  62:	18 d0       	rcall	.+48     	; 0x94 <wdt_timeout_happened>
  64:	81 11       	cpse	r24, r1
  66:	48 d0       	rcall	.+144    	; 0xf8 <wdt_event>
#endif
		loop();
  68:	e0 d0       	rcall	.+448    	; 0x22a <loop>
	}
  6a:	fa cf       	rjmp	.-12     	; 0x60 <main+0xe>

0000006c <pwm_init>:
#include "wdt.h"

#if OC0AB > 0

void pwm_init(void){
	TCCR0A =
  6c:	81 e8       	ldi	r24, 0x81	; 129
  6e:	8f bd       	out	0x2f, r24	; 47
#if OC0AB >= 2
		_BV(COM0B1) +
#endif
		_BV(WGM00);  // phase correct PWM mode

	DDRB |=
  70:	b8 9a       	sbi	0x17, 0	; 23
#if OC0AB >= 2
		_BV(1) +
#endif
	0 ;

	TCCR0B = _BV(CS01);   // clock source = CLK/1, start PWM
  72:	82 e0       	ldi	r24, 0x02	; 2
  74:	83 bf       	out	0x33, r24	; 51
	disable_deep_sleep();
  76:	3c c0       	rjmp	.+120    	; 0xf0 <disable_deep_sleep>

00000078 <pwm_disable>:
}

void pwm_disable(void){
	TCCR0A = 0;
  78:	1f bc       	out	0x2f, r1	; 47
  7a:	08 95       	ret

0000007c <is_pwm_disabled>:
}

bool is_pwm_disabled(void){
	return TCCR0A == 0;
  7c:	9f b5       	in	r25, 0x2f	; 47
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	91 11       	cpse	r25, r1
  82:	80 e0       	ldi	r24, 0x00	; 0
}
  84:	08 95       	ret

00000086 <wdt_setup>:
#endif

volatile uint32_t ts = 0; // timestamp

void wdt_setup(){
	MCUCR |= _BV(SE); // Enable sleep mode
  86:	85 b7       	in	r24, 0x35	; 53
  88:	80 62       	ori	r24, 0x20	; 32
  8a:	85 bf       	out	0x35, r24	; 53
	sei();
  8c:	78 94       	sei
	#if FIXED_WDT_PER
	WDTCR = _BV(WDIE) + FIXED_WDT_PER;
  8e:	81 e4       	ldi	r24, 0x41	; 65
  90:	81 bd       	out	0x21, r24	; 33
  92:	08 95       	ret

00000094 <wdt_timeout_happened>:


bool wdt_event_f = false;

bool wdt_timeout_happened(void){
	if (wdt_event_f){
  94:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
  98:	81 11       	cpse	r24, r1
		wdt_event_f = 0;
  9a:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <__data_end>
		return 1;
	}
	return 0;
}
  9e:	08 95       	ret

000000a0 <__vector_8>:

#if WDT

ISR(WDT_vect){
  a0:	1f 92       	push	r1
  a2:	0f 92       	push	r0
  a4:	0f b6       	in	r0, 0x3f	; 63
  a6:	0f 92       	push	r0
  a8:	11 24       	eor	r1, r1
  aa:	8f 93       	push	r24
  ac:	9f 93       	push	r25
  ae:	af 93       	push	r26
  b0:	bf 93       	push	r27
	ts += wdt_per_ts;
  b2:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <ts>
  b6:	90 91 64 00 	lds	r25, 0x0064	; 0x800064 <ts+0x1>
  ba:	a0 91 65 00 	lds	r26, 0x0065	; 0x800065 <ts+0x2>
  be:	b0 91 66 00 	lds	r27, 0x0066	; 0x800066 <ts+0x3>
  c2:	02 96       	adiw	r24, 0x02	; 2
  c4:	a1 1d       	adc	r26, r1
  c6:	b1 1d       	adc	r27, r1
  c8:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <ts>
  cc:	90 93 64 00 	sts	0x0064, r25	; 0x800064 <ts+0x1>
  d0:	a0 93 65 00 	sts	0x0065, r26	; 0x800065 <ts+0x2>
  d4:	b0 93 66 00 	sts	0x0066, r27	; 0x800066 <ts+0x3>
	wdt_event_f = true;
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__data_end>
}
  de:	bf 91       	pop	r27
  e0:	af 91       	pop	r26
  e2:	9f 91       	pop	r25
  e4:	8f 91       	pop	r24
  e6:	0f 90       	pop	r0
  e8:	0f be       	out	0x3f, r0	; 63
  ea:	0f 90       	pop	r0
  ec:	1f 90       	pop	r1
  ee:	18 95       	reti

000000f0 <disable_deep_sleep>:

void disable_deep_sleep(void){
	clr_bit(MCUCR, SM1); // Disable deep sleep (CPU usage jumps from 5uA tp 800uA)
  f0:	85 b7       	in	r24, 0x35	; 53
  f2:	8f 7e       	andi	r24, 0xEF	; 239
  f4:	85 bf       	out	0x35, r24	; 53
  f6:	08 95       	ret

000000f8 <wdt_event>:

bool incr = true;

void wdt_event(void)
{
	set_bit(PORTB, TOUCH_PIN);
  f8:	c3 9a       	sbi	0x18, 3	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  fa:	82 e0       	ldi	r24, 0x02	; 2
  fc:	8a 95       	dec	r24
  fe:	f1 f7       	brne	.-4      	; 0xfc <wdt_event+0x4>
 100:	00 c0       	rjmp	.+0      	; 0x102 <wdt_event+0xa>
	_delay_us(1);
	bool touch = is_pin_clr(TOUCH_PIN);
 102:	26 b3       	in	r18, 0x16	; 22
	clr_bit(PORTB, TOUCH_PIN);
 104:	c3 98       	cbi	0x18, 3	; 24
	
	if (count_lock) count_lock--;
 106:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <count_lock>
 10a:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <count_lock+0x1>
 10e:	00 97       	sbiw	r24, 0x00	; 0
 110:	11 f0       	breq	.+4      	; 0x116 <wdt_event+0x1e>
 112:	01 97       	sbiw	r24, 0x01	; 1
 114:	25 c0       	rjmp	.+74     	; 0x160 <wdt_event+0x68>
	else if (touch){
 116:	23 fd       	sbrc	r18, 3
 118:	6b c0       	rjmp	.+214    	; 0x1f0 <wdt_event+0xf8>
		if ((ts - command_ts) > MS_TO_TS(2000) && OCR0A > 0) {OCR0A = 0; incr = true; pwm_disable(); count_lock = 10;}
 11a:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <ts>
 11e:	90 91 64 00 	lds	r25, 0x0064	; 0x800064 <ts+0x1>
 122:	a0 91 65 00 	lds	r26, 0x0065	; 0x800065 <ts+0x2>
 126:	b0 91 66 00 	lds	r27, 0x0066	; 0x800066 <ts+0x3>
 12a:	40 91 67 00 	lds	r20, 0x0067	; 0x800067 <command_ts>
 12e:	50 91 68 00 	lds	r21, 0x0068	; 0x800068 <command_ts+0x1>
 132:	60 91 69 00 	lds	r22, 0x0069	; 0x800069 <command_ts+0x2>
 136:	70 91 6a 00 	lds	r23, 0x006A	; 0x80006a <command_ts+0x3>
 13a:	84 1b       	sub	r24, r20
 13c:	95 0b       	sbc	r25, r21
 13e:	a6 0b       	sbc	r26, r22
 140:	b7 0b       	sbc	r27, r23
 142:	8e 37       	cpi	r24, 0x7E	; 126
 144:	91 05       	cpc	r25, r1
 146:	a1 05       	cpc	r26, r1
 148:	b1 05       	cpc	r27, r1
 14a:	78 f0       	brcs	.+30     	; 0x16a <wdt_event+0x72>
 14c:	86 b7       	in	r24, 0x36	; 54
 14e:	88 23       	and	r24, r24
 150:	61 f0       	breq	.+24     	; 0x16a <wdt_event+0x72>
 152:	16 be       	out	0x36, r1	; 54
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 15a:	8e df       	rcall	.-228    	; 0x78 <pwm_disable>
 15c:	8a e0       	ldi	r24, 0x0A	; 10
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <count_lock+0x1>
 164:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <count_lock>
 168:	43 c0       	rjmp	.+134    	; 0x1f0 <wdt_event+0xf8>
		else{
			if (incr) OCR0A += 10;
 16a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 16e:	88 23       	and	r24, r24
 170:	19 f0       	breq	.+6      	; 0x178 <wdt_event+0x80>
 172:	86 b7       	in	r24, 0x36	; 54
 174:	86 5f       	subi	r24, 0xF6	; 246
 176:	02 c0       	rjmp	.+4      	; 0x17c <wdt_event+0x84>
			else OCR0A -= 10;
 178:	86 b7       	in	r24, 0x36	; 54
 17a:	8a 50       	subi	r24, 0x0A	; 10
 17c:	86 bf       	out	0x36, r24	; 54
			if (OCR0A == 250) {incr = false; count_lock = 10;}
 17e:	86 b7       	in	r24, 0x36	; 54
 180:	8a 3f       	cpi	r24, 0xFA	; 250
 182:	41 f4       	brne	.+16     	; 0x194 <wdt_event+0x9c>
 184:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_start>
 188:	8a e0       	ldi	r24, 0x0A	; 10
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <count_lock+0x1>
 190:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <count_lock>
			if (OCR0A == 0) {OCR0A = 0; incr = true; pwm_disable(); count_lock = 10;}
 194:	86 b7       	in	r24, 0x36	; 54
 196:	81 11       	cpse	r24, r1
 198:	0c c0       	rjmp	.+24     	; 0x1b2 <wdt_event+0xba>
 19a:	16 be       	out	0x36, r1	; 54
 19c:	81 e0       	ldi	r24, 0x01	; 1
 19e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 1a2:	6a df       	rcall	.-300    	; 0x78 <pwm_disable>
 1a4:	8a e0       	ldi	r24, 0x0A	; 10
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <count_lock+0x1>
 1ac:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <count_lock>
 1b0:	03 c0       	rjmp	.+6      	; 0x1b8 <wdt_event+0xc0>
			else if (is_pwm_disabled()) pwm_init();
 1b2:	64 df       	rcall	.-312    	; 0x7c <is_pwm_disabled>
 1b4:	81 11       	cpse	r24, r1
 1b6:	5a df       	rcall	.-332    	; 0x6c <pwm_init>
			count_on = CONN_TIMEOUT_SECS*wdt_frq_hz;
 1b8:	80 e2       	ldi	r24, 0x20	; 32
 1ba:	91 e0       	ldi	r25, 0x01	; 1
 1bc:	a0 e0       	ldi	r26, 0x00	; 0
 1be:	b0 e0       	ldi	r27, 0x00	; 0
 1c0:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <count_on>
 1c4:	90 93 6e 00 	sts	0x006E, r25	; 0x80006e <count_on+0x1>
 1c8:	a0 93 6f 00 	sts	0x006F, r26	; 0x80006f <count_on+0x2>
 1cc:	b0 93 70 00 	sts	0x0070, r27	; 0x800070 <count_on+0x3>
			command_ts = ts;
 1d0:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <ts>
 1d4:	90 91 64 00 	lds	r25, 0x0064	; 0x800064 <ts+0x1>
 1d8:	a0 91 65 00 	lds	r26, 0x0065	; 0x800065 <ts+0x2>
 1dc:	b0 91 66 00 	lds	r27, 0x0066	; 0x800066 <ts+0x3>
 1e0:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <command_ts>
 1e4:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <command_ts+0x1>
 1e8:	a0 93 69 00 	sts	0x0069, r26	; 0x800069 <command_ts+0x2>
 1ec:	b0 93 6a 00 	sts	0x006A, r27	; 0x80006a <command_ts+0x3>
		}
	}
	
	if (count_on) count_on--;
 1f0:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <count_on>
 1f4:	90 91 6e 00 	lds	r25, 0x006E	; 0x80006e <count_on+0x1>
 1f8:	a0 91 6f 00 	lds	r26, 0x006F	; 0x80006f <count_on+0x2>
 1fc:	b0 91 70 00 	lds	r27, 0x0070	; 0x800070 <count_on+0x3>
 200:	00 97       	sbiw	r24, 0x00	; 0
 202:	a1 05       	cpc	r26, r1
 204:	b1 05       	cpc	r27, r1
 206:	61 f0       	breq	.+24     	; 0x220 <wdt_event+0x128>
 208:	01 97       	sbiw	r24, 0x01	; 1
 20a:	a1 09       	sbc	r26, r1
 20c:	b1 09       	sbc	r27, r1
 20e:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <count_on>
 212:	90 93 6e 00 	sts	0x006E, r25	; 0x80006e <count_on+0x1>
 216:	a0 93 6f 00 	sts	0x006F, r26	; 0x80006f <count_on+0x2>
 21a:	b0 93 70 00 	sts	0x0070, r27	; 0x800070 <count_on+0x3>
 21e:	08 95       	ret
	else {OCR0A = 0; incr = true; pwm_disable();}
 220:	16 be       	out	0x36, r1	; 54
 222:	81 e0       	ldi	r24, 0x01	; 1
 224:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 228:	27 cf       	rjmp	.-434    	; 0x78 <pwm_disable>

0000022a <loop>:
}

void loop(void){}
 22a:	08 95       	ret

0000022c <init>:

void init(){
	
	adc_init();
 22c:	0d df       	rcall	.-486    	; 0x48 <adc_init>
	wdt_setup();
 22e:	2b df       	rcall	.-426    	; 0x86 <wdt_setup>
#if (OC0AB > 0)
	pwm_init();
 230:	1d cf       	rjmp	.-454    	; 0x6c <pwm_init>

00000232 <_exit>:
 232:	f8 94       	cli

00000234 <__stop_program>:
 234:	ff cf       	rjmp	.-2      	; 0x234 <__stop_program>
